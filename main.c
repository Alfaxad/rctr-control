/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <stdio.h>

// micro-ROS includes
#include <rcl/rcl.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#include <rmw_microros/rmw_microros.h>

// ROS2 message includes
#include <geometry_msgs/msg/twist.h>
#include <std_msgs/msg/float32_multi_array.h>
#include <nav_msgs/msg/odometry.h>
#include <sensor_msgs/msg/imu.h>

// --- HAL Handles (Generated by CubeMX, ensure names match) ---
extern I2C_HandleTypeDef hi2c1;  // For PCA9685 and IMU
extern TIM_HandleTypeDef htim1;  // Motor L PWM
extern TIM_HandleTypeDef htim2;  // Motor R PWM
extern TIM_HandleTypeDef htim3;  // Encoder L
extern TIM_HandleTypeDef htim4;  // Encoder R
extern TIM_HandleTypeDef htim6;  // Control Loop Timer
extern UART_HandleTypeDef huart2; // For micro-ROS communication

// --- Pin Definitions (Managed by CubeMX, this is for reference) ---
// L298N Direction Pins: e.g., MOTOR_L_IN1_Pin, MOTOR_L_IN1_GPIO_Port

// --- Robot Physical Constants (TODO: TUNE THESE VALUES) ---
const float WHEEL_DIAMETER = 0.065; // meters
const float WHEEL_BASE = 0.25;      // meters
const float TICKS_PER_REVOLUTION = 480.0; // Ticks for one wheel turn
const float CONTROL_LOOP_FREQ = 50.0; // Hz

// --- PID Controller ---
typedef struct {
    float Kp, Ki, Kd;
    float integral, prev_error;
} PID_Controller;

float PID_Compute(PID_Controller *pid, float setpoint, float measured) {
    float error = setpoint - measured;
    pid->integral += error;
    float derivative = error - pid->prev_error;
    pid->prev_error = error;
    return pid->Kp * error + pid->Ki * pid->integral + pid->Kd * derivative;
}

// --- Global Variables ---
PID_Controller pid_l, pid_r;
float target_speed_l = 0.0, target_speed_r = 0.0; // m/s

// micro-ROS objects
rclc_executor_t executor;
rclc_support_t support;
rcl_allocator_t allocator;
rcl_node_t node;
rcl_timer_t timer;
rcl_publisher_t odom_publisher, imu_publisher;
rcl_subscription_t twist_subscriber, servo_subscriber;

nav_msgs__msg__Odometry odom_msg;
sensor_msgs__msg__Imu imu_msg;
geometry_msgs__msg__Twist twist_msg;
// For servo msg, you might need to pre-allocate memory
std_msgs__msg__Float32MultiArray servo_msg;
float servo_data[16]; // Max servos on PCA9685

// --- Helper Functions ---
void set_motor_pwm(char motor, int pwm) {
    pwm = (pwm > 1000) ? 1000 : ((pwm < -1000) ? -1000 : pwm); // Clamp pwm (assuming ARR is 1000)
    if (motor == 'L') {
        if (pwm > 0) {
            HAL_GPIO_WritePin(MOTOR_L_IN1_GPIO_Port, MOTOR_L_IN1_Pin, GPIO_PIN_SET);
            HAL_GPIO_WritePin(MOTOR_L_IN2_GPIO_Port, MOTOR_L_IN2_Pin, GPIO_PIN_RESET);
        } else {
            HAL_GPIO_WritePin(MOTOR_L_IN1_GPIO_Port, MOTOR_L_IN1_Pin, GPIO_PIN_RESET);
            HAL_GPIO_WritePin(MOTOR_L_IN2_GPIO_Port, MOTOR_L_IN2_Pin, GPIO_PIN_SET);
        }
        __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, abs(pwm));
    } else if (motor == 'R') {
        // Similar logic for Right Motor
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, abs(pwm));
    }
}

// --- ROS2 Callbacks ---
void twist_callback(const void * mgs_in) {
    const geometry_msgs__msg__Twist * twist = (const geometry_msgs__msg__Twist *)mgs_in;
    target_speed_r = twist->linear.x + (twist->angular.z * WHEEL_BASE / 2.0);
    target_speed_l = twist->linear.x - (twist->angular.z * WHEEL_BASE / 2.0);
}

void servo_callback(const void * mgs_in) {
    // I2C communication logic for PCA9685
    // This is more complex with HAL and requires a PCA9685 HAL library
    // or manual implementation of the I2C protocol.
}

// --- Control Loop Timer Callback ---
void control_loop_callback(rcl_timer_t * timer, int64_t last_call_time) {
    // 1. Read Encoder Counts
    int16_t encoder_l_ticks = (int16_t)__HAL_TIM_GET_COUNTER(&htim3);
    int16_t encoder_r_ticks = (int16_t)__HAL_TIM_GET_COUNTER(&htim4);
    __HAL_TIM_SET_COUNTER(&htim3, 0); // Reset counters
    __HAL_TIM_SET_COUNTER(&htim4, 0);

    // 2. Calculate current speeds
    float wheel_circ = 3.14159f * WHEEL_DIAMETER;
    float dt = 1.0f / CONTROL_LOOP_FREQ;
    float speed_l = ((float)encoder_l_ticks / TICKS_PER_REVOLUTION) * wheel_circ / dt;
    float speed_r = ((float)encoder_r_ticks / TICKS_PER_REVOLUTION) * wheel_circ / dt;

    // 3. Compute PID and set motors
    int pwm_l = (int)PID_Compute(&pid_l, target_speed_l, speed_l);
    int pwm_r = (int)PID_Compute(&pid_r, target_speed_r, speed_r);
    set_motor_pwm('L', pwm_l);
    set_motor_pwm('R', pwm_r);

    // 4. Update and Publish Odometry
    // TODO: Implement odometry calculation and publish
    rcl_publish(&odom_publisher, &odom_msg, NULL);

    // 5. Read and Publish IMU
    // TODO: Implement I2C read from IMU and publish
    rcl_publish(&imu_publisher, &imu_msg, NULL);
}

int main(void) {
    HAL_Init();
    // Assuming SystemClock_Config() is called here by CubeMX
    
    // Initialize all configured peripherals
    // MX_GPIO_Init(); MX_TIM1_Init(); etc...

    // Start Timers
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
    HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
    HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);
    HAL_TIM_Base_Start_IT(&htim6); // Start control loop timer

    // PID Tuning (TODO: TUNE THESE VALUES!)
    pid_l = (PID_Controller){ .Kp = 2000.0, .Ki = 100.0, .Kd = 50.0 };
    pid_r = (PID_Controller){ .Kp = 2000.0, .Ki = 100.0, .Kd = 50.0 };

    // --- micro-ROS Setup ---
    rmw_uros_set_custom_transport(
        true,
        (void *)&huart2,
        cubemx_transport_open,
        cubemx_transport_close,
        cubemx_transport_write,
        cubemx_transport_read
    );

    allocator = rcl_get_default_allocator();
    rclc_support_init(&support, 0, NULL, &allocator);
    rclc_node_init_default(&node, "stm32_motor_controller", "", &support);

    // Publishers & Subscribers
    rclc_publisher_init_default(&odom_publisher, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(nav_msgs, msg, Odometry), "/odom");
    rclc_subscription_init_default(&twist_subscriber, &node, ROSIDL_GET_MSG_TYPE_SUPPORT(geometry_msgs, msg, Twist), "/cmd_vel");
    
    // Timer
    rclc_timer_init_default(&timer, &support, RCL_MS_TO_NS(1000 / CONTROL_LOOP_FREQ), control_loop_callback);

    // Executor
    rclc_executor_init(&executor, &support.context, 1, &allocator); // 1 subscription for now
    rclc_executor_add_subscription(&executor, &twist_subscriber, &twist_msg, &twist_callback, ON_NEW_DATA);
    rclc_executor_add_timer(&executor, &timer);

    while (1) {
        rclc_executor_spin_some(&executor, RCL_MS_TO_NS(10));
    }
}
